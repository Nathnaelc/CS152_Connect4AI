import numpy as np
import pygame
import sys
import random
import time

# Constants for the game
GRID_COLOR = (0, 0, 180)
COLOR_BLACK = (0, 0, 0)
COLOR_GREEN = (0, 255, 0)
COLOR_YELLOW = (255, 255, 0)

# Game player identifiers
PLAYER_HUMAN = 0
PLAYER_AI = 1

# large number
POSITIVE = 10000000
NEGATIVE = -10000000


# Piece types
PIECE_EMPTY = 0
PIECE_HUMAN = 1
PIECE_AI = 2

# Winning condition line segment length
WINNING_LENGTH = 4


class Connect4Game:

    def __init__(self, row_count, column_count):
        # Initialize the game with the given row and column count, and AI depth
        self.row_count = row_count
        self.column_count = column_count
        self.board = self.create_board()
        self.ai = Connect4AI(self)

    def create_board(self):
        """
        Create a 2D numpy array for the game board.
        The board is initialized with zeros, indicating all cells are empty.
        """
        return np.zeros((self.row_count, self.column_count))

    def place_disc(self, board, row, col, piece):
        """
        Drop a disc in the specified column.
        The piece/disc is placed in the given row and column on the board.
        """
        board[row][col] = piece

    def is_column_open(self, board, col):
        """
        Check if the top cell in the specified column is empty.
        Returns True if the cell is empty, False otherwise.
        """
        return board[self.row_count - 1][col] == PIECE_EMPTY

    def find_open_row(self, board, col):
        """
        Find the next open row in the specified column.
        Returns the row index if an empty cell is found, None otherwise.
        """
        for r in range(self.row_count):
            if board[r][col] == PIECE_EMPTY:

                return r

    def display_board(self):  # not being used
        """
        Print the game board.
        The board is flipped vertically before printing, so the first row printed is the bottom row of the game board.
        """
        print(np.flip(self.board, 0))

    def reset_game(self):
        """
        Reset the game by clearing the board and resetting variables.
        The board is reinitialized to its original state with all cells empty.
        """
        self.board = self.create_board()

    def is_winning_pattern(self, board, piece):
        """
        Check if there is a winning pattern on the board for the given piece.
        A winning pattern is four pieces of the same type in a row, column, or diagonal.
        The function checks all possible directions (horizontal, vertical, and two diagonals) for a winning pattern.
        Returns True if a winning pattern is found, False otherwise.
        """
        if piece == PIECE_EMPTY:  # Ensure we are not checking for empty pieces
            return False

        # Horizontal check
        # For each row, check if there are four consecutive pieces of the same type
        for c in range(self.column_count - 3):
            for r in range(self.row_count):
                if board[r][c] == piece and board[r][c + 1] == piece and \
                        board[r][c + 2] == piece and board[r][c + 3] == piece:
                    return True

        # Vertical check
        # For each column, check if there are four consecutive pieces of the same type
        for c in range(self.column_count):
            for r in range(self.row_count - 3):
                if board[r][c] == piece and board[r + 1][c] == piece and \
                        board[r + 2][c] == piece and board[r + 3][c] == piece:
                    return True

        # Positive diagonal check
        # For each cell that can be the start of a positive sloped diagonal, check if there are four consecutive pieces of the same type
        for c in range(self.column_count - 3):
            for r in range(self.row_count - 3):
                if board[r][c] == piece and board[r + 1][c + 1] == piece and \
                        board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:
                    return True

        # Negative diagonal check
        # For each cell that can be the start of a negative sloped diagonal, check if there are four consecutive pieces of the same type
        for c in range(self.column_count - 3):
            for r in range(3, self.row_count):
                if board[r][c] == piece and board[r - 1][c + 1] == piece and \
                        board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:
                    return True

        return False


class Connect4AI:
    def __init__(self, game, depth=5):
        """
        Initialize the AI with a game and a search depth.
        """
        self.game = game
        self.depth = depth

    def calculate_dynamic_depth(self, board):
        """
        Calculate the appropriate depth for the minimax algorithm dynamically
        based on the current state of the board.
        """
        empty_cells = np.count_nonzero(board == PIECE_EMPTY)
        total_cells = self.game.row_count * self.game.column_count

        # Base depth starts at a minimum value
        base_depth = 7

        # Increase depth as the game progresses
        if empty_cells / total_cells < 0.5:  # More than half of the board is filled
            return base_depth + 1
        if empty_cells / total_cells < 0.25:  # 75% of the board is filled
            return base_depth + 2

        # Further increase if a player is close to winning
        if self.is_near_win(board):
            return base_depth + 3

        return base_depth

    def is_near_win(self, board):
        """
        Check if either player is close to winning (e.g., three in a row).
        """
        for piece in [PIECE_HUMAN, PIECE_AI]:
            # Check horizontal locations for near win
            for c in range(self.game.column_count - 3):
                for r in range(self.game.row_count):
                    if sum([board[r][c + i] == piece for i in range(WINNING_LENGTH - 1)]) == 3 and \
                            PIECE_EMPTY in [board[r][c + i] for i in range(WINNING_LENGTH)]:
                        return True

            # Check vertical locations for near win
            for c in range(self.game.column_count):
                for r in range(self.game.row_count - 3):
                    if sum([board[r + i][c] == piece for i in range(WINNING_LENGTH - 1)]) == 3 and \
                            PIECE_EMPTY in [board[r + i][c] for i in range(WINNING_LENGTH)]:
                        return True

            # Check positively sloped diagonals
            for c in range(self.game.column_count - 3):
                for r in range(self.game.row_count - 3):
                    if sum([board[r + i][c + i] == piece for i in range(WINNING_LENGTH - 1)]) == 3 and \
                            PIECE_EMPTY in [board[r + i][c + i] for i in range(WINNING_LENGTH)]:
                        return True

            # Check negatively sloped diagonals
            for c in range(self.game.column_count - 3):
                for r in range(3, self.game.row_count):
                    if sum([board[r - i][c + i] == piece for i in range(WINNING_LENGTH - 1)]) == 3 and \
                            PIECE_EMPTY in [board[r - i][c + i] for i in range(WINNING_LENGTH)]:
                        return True

        return False

    def find_playable_columns(self, board):
        """
        Get a list of columns that can accept a new piece.
        The list is generated by checking each column in the board to see if it can accept a new piece.
        """
        playable_columns = []
        for col in range(self.game.column_count):
            # Using the provided board parameter
            if self.game.is_column_open(board, col):
                playable_columns.append(col)
        # print(f"Valid locations: {playable_columns}")  # Debugging statement
        return playable_columns

    def is_game_over(self, board):
        """
        Check if the game is over.
        The game is over if there is a winning pattern for the AI or the human, or if there are no playable columns left on the board.
        Returns True if the game is over, False otherwise.
        """
        if self.game.is_winning_pattern(board, PLAYER_AI):
            return True
        if self.game.is_winning_pattern(board, PLAYER_HUMAN):
            return True
        if len(self.find_playable_columns(board)) == 0:
            return True
        return False

    def assess_line(self, line_segment, piece):
        """
        Assess the score of a line segment.
        The score is calculated based on the number of pieces and empty cells in the line segment.
        The score is higher if there are more pieces and fewer empty cells.
        The score is also adjusted based on the presence of the opponent's pieces.
        """
        score = 0
        opponent_piece = PIECE_HUMAN
        if piece == PIECE_HUMAN:
            opponent_piece = PIECE_AI

        if line_segment.count(piece) == 4:
            score += 1000
        elif line_segment.count(piece) == 3 and line_segment.count(PIECE_EMPTY) == 1:
            score += 50
        elif line_segment.count(piece) == 2 and line_segment.count(PIECE_EMPTY) == 2:
            score += 10
        if line_segment.count(opponent_piece) == 3 and line_segment.count(PIECE_EMPTY) == 1:
            score -= 25

        return score

    def evaluate_board_state(self, board, piece):
        """
        Calculate the score for the AI's current board position.
        The score is calculated based on the number of pieces in the center column and the score of all directions on the board.
        """
        score = 0

        # Center column preference (since it's advantageous to play in the center)
        center_array = [int(i) for i in list(
            board[:, self.game.column_count // 2])]
        center_count = center_array.count(piece)
        score += center_count * 3

       # Prioritize immediate winning opportunities and blocking opponent's wins
        for c in range(self.game.column_count - 3):
            for r in range(self.game.row_count):
                for i in range(WINNING_LENGTH - 1):
                    line_segment = [board[r][c + i]
                                    for i in range(WINNING_LENGTH)]
                    if line_segment.count(piece) == 3 and line_segment.count(PIECE_EMPTY) == 1:
                        score += 10000  # High score for potential win
                    if line_segment.count(3 - piece) == 3 and line_segment.count(PIECE_EMPTY) == 1:
                        score -= 5000   # Negative score to block opponent's win

        # Horizontal scoring
        for r in range(self.game.row_count):
            row_array = [int(i) for i in list(board[r, :])]
            for c in range(self.game.column_count - 3):
                line_segment = row_array[c:c + WINNING_LENGTH]
                score += self.assess_line(line_segment, piece)

        # Vertical scoring
        for c in range(self.game.column_count):
            col_array = [int(i) for i in list(board[:, c])]
            for r in range(self.game.row_count - 3):
                line_segment = col_array[r:r + WINNING_LENGTH]
                score += self.assess_line(line_segment, piece)

        # Positive diagonal scoring
        for r in range(self.game.row_count - 3):
            for c in range(self.game.column_count - 3):
                line_segment = [board[r + i][c + i]
                                for i in range(WINNING_LENGTH)]
                score += self.assess_line(line_segment, piece)

        # Negative diagonal scoring
        for r in range(self.game.row_count - 3):
            for c in range(self.game.column_count - 3):
                line_segment = [board[r + 3 - i][c + i]
                                for i in range(WINNING_LENGTH)]
                score += self.assess_line(line_segment, piece)

        return score

    def minimax(self, board, depth, alpha, beta, maximizingPlayer):
        """
        Implement the minimax algorithm with alpha-beta pruning.
        The algorithm recursively searches the game tree to the specified depth and returns the best move and its score.
        The function also measures the time it takes to make a decision.
        """
        start_time = time.time()
        playable_columns = self.find_playable_columns(board)
        is_terminal = self.is_game_over(board)

        if depth == 0 or is_terminal:
            if is_terminal:
                if self.game.is_winning_pattern(board, PLAYER_AI):
                    return (None, POSITIVE - (self.game.row_count * self.game.column_count - depth))
                elif self.game.is_winning_pattern(board, PLAYER_HUMAN):
                    return (None, NEGATIVE + (self.game.row_count * self.game.column_count - depth))
                else:
                    return (None, 0)
            else:
                return (None, self.evaluate_board_state(board, PLAYER_AI))

        if maximizingPlayer:
            value = float('-inf')
            column = random.choice(playable_columns)
            for col in playable_columns:
                row = self.game.find_open_row(board, col)
                b_copy = board.copy()
                self.game.place_disc(b_copy, row, col, PLAYER_AI)
                new_score = self.minimax(
                    b_copy, depth - 1, alpha, beta, False)[1]

                if new_score > value:
                    value = new_score
                    column = col
                alpha = max(alpha, value)
                if alpha >= beta:
                    break
            end_time = time.time()
            decision_time = end_time - start_time
            # print(f"Column chosen: {column}, Score: {value}")
            return column, value, decision_time

        else:  # Minimizing player
            value = float('inf')
            column = random.choice(playable_columns)
            for col in playable_columns:
                row = self.game.find_open_row(board, col)
                b_copy = board.copy()
                self.game.place_disc(b_copy, row, col, PLAYER_HUMAN)
                new_score = self.minimax(
                    b_copy, depth - 1, alpha, beta, True)[1]

                if new_score < value:
                    value = new_score
                    column = col
                beta = min(beta, value)
                if alpha >= beta:
                    break
            end_time = time.time()
            decision_time = end_time - start_time
            # print(f"Column chosen: {column}, Score: {value}")
            return column, value, decision_time


def main():
    row_count = int(input("Enter the number of rows: "))
    column_count = int(input("Enter the number of columns: "))

    if row_count < 4 or column_count < 4:
        print("The Connect 4 board must have at least 4 rows and 4 columns.")
        return
    if row_count > 14 or column_count > 15:
        print("The Connect 4 board can have at most 14 rows and 15 columns.")
        return

    game = Connect4Game(row_count, column_count)
    CELL_SIZE = 100
    pygame.init()
    screen = pygame.display.set_mode(
        (game.column_count * CELL_SIZE, game.row_count * CELL_SIZE))

    game.reset_game()

    def draw_board(board):
        """
        Draw the game board using Pygame.
        The board is drawn as a grid of cells, with each cell representing a slot for a piece.
        Each piece is drawn as a circle in the cell.
        The color of the circle depends on the type of the piece (human or AI).
        """
        for c in range(game.column_count):
            for r in range(game.row_count):
                pygame.draw.rect(screen, GRID_COLOR, (c * CELL_SIZE,
                                 (game.row_count - 1 - r) * CELL_SIZE, CELL_SIZE, CELL_SIZE))
                pygame.draw.circle(screen, COLOR_BLACK, (int(c * CELL_SIZE + CELL_SIZE / 2), int(
                    (game.row_count - 1 - r) * CELL_SIZE + CELL_SIZE / 2)), CELL_SIZE // 2 - 5)

                if board[r][c] == PIECE_HUMAN:
                    pygame.draw.circle(screen, COLOR_GREEN, (int(c * CELL_SIZE + CELL_SIZE / 2), int(
                        (game.row_count - 1 - r) * CELL_SIZE + CELL_SIZE / 2)), CELL_SIZE // 2 - 5)
                elif board[r][c] == PIECE_AI:
                    pygame.draw.circle(screen, COLOR_YELLOW, (int(c * CELL_SIZE + CELL_SIZE / 2), int(
                        (game.row_count - 1 - r) * CELL_SIZE + CELL_SIZE / 2)), CELL_SIZE // 2 - 5)

        pygame.display.update()

    def display_message(screen, message):
        """
        Display a message in the center of the screen.
        The message is displayed for 3 seconds.
        """
        font = pygame.font.Font(None, 36)
        text = font.render(message, True, (255, 255, 255))  # White color
        text_rect = text.get_rect(
            center=(screen.get_width()/2, screen.get_height()/2))
        screen.blit(text, text_rect)
        pygame.display.update()
        pygame.time.wait(3000)  # Wait for 3 seconds

    while True:
        game_over = False
        turn = random.randint(PLAYER_HUMAN, PLAYER_AI)
        draw_board(game.board)

        while not game_over:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                if event.type == pygame.MOUSEBUTTONDOWN and turn == PLAYER_HUMAN:
                    pos_x, pos_y = pygame.mouse.get_pos()
                    clicked_column = pos_x // CELL_SIZE
                    if game.is_column_open(game.board, clicked_column):
                        row = game.find_open_row(
                            game.board, clicked_column)
                        game.place_disc(game.board, row,
                                        clicked_column, PIECE_HUMAN)
                        if game.is_winning_pattern(game.board, PIECE_HUMAN):
                            game_over = True
                        turn = PLAYER_AI

                        draw_board(game.board)

            # Inside the main game loop
            if turn == PLAYER_AI and not game_over:
                dynamic_depth = game.ai.calculate_dynamic_depth(game.board)
                column = game.ai.minimax(
                    game.board, dynamic_depth, float('-inf'), float('inf'), True)[0]
                # print('Column is', column)
                if column is not None:
                    if game.is_column_open(game.board, column):
                        row = game.find_open_row(game.board, column)
                        game.place_disc(game.board, row, column, PIECE_AI)
                        if game.is_winning_pattern(game.board, PIECE_AI):
                            game_over = True
                        turn = PLAYER_HUMAN
                else:
                    # Handle the case when there are no valid moves left
                    game_over = True
                    display_message(screen, "It's a a draw!")

            draw_board(game.board)
            pygame.display.update()

            # Handling end of the game and displaying messages
        # After the game is over, display the appropriate message
        if game.is_winning_pattern(game.board, PIECE_HUMAN):
            display_message(screen, "Congratulations! You win!")
        elif game.is_winning_pattern(game.board, PIECE_AI):
            display_message(screen, "AI wins! Better luck next time.")
        else:
            display_message(screen, "It's a draw!")

        waiting_for_input = True
        while waiting_for_input:
            for event in pygame.event.get():
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_r:
                        waiting_for_input = False
                        game.reset_game()
                        draw_board(game.board)
                        # main()  # Restart the game
                        break
                    if event.key == pygame.K_q:
                        pygame.quit()
                        sys.exit()
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()


if __name__ == "__main__":
    while True:
        main()
